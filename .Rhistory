xlab("# Variables") +
ylab("R-squared") +
theme_bw()
# RSS
plot_RSS = ggplot(data = data.frame(summary(model[[.x]])$rss),
aes(x = num_variables, y = summary(model[[.x]])$rss)) +
geom_line() +
geom_point(x = which.min(summary(model[[.x]])$rss),
y = min(summary(model[[.x]])$rss), aes(color = "red"),
show.legend = FALSE) +
xlab("# Variables") +
ylab("RSS") +
theme_bw()
# BIC
plot_BIC = ggplot(data = data.frame(summary(model[[.x]])$bic),
aes(x = num_variables, y = summary(model[[.x]])$bic)) +
geom_line() +
geom_point(x = which.min(summary(model[[.x]])$bic),
y = min(summary(model[[.x]])$bic), aes(color = "red"),
show.legend = FALSE) +
xlab("# Variables") +
ylab("BIC") +
ggtitle("BIC",
str_c("Optimal value at ", which.min(summary(model[[.x]])$bic))) +
theme_bw()
# AIC
plot_AIC = ggplot(data = data.frame(summary(model[[.x]])$cp),
aes(x = num_variables, y = summary(model[[.x]])$cp)) +
geom_line() +
geom_point(x = which.min(summary(model[[.x]])$cp),
y = min(summary(model[[.x]])$cp), aes(color = "red"),
show.legend = FALSE) +
xlab("# Variables") +
ylab("AIC") +
ggtitle("AIC",
str_c("Optimal value at ", which.min(summary(model[[.x]])$cp))) +
theme_bw()
# Plot
gridExtra::grid.arrange(plot_RSQ, plot_RSS, plot_AIC, plot_BIC,
ncol = 2, nrow = 2)
}
model_coef = map(1:2,
~coef(model[[.x]], which.min(summary(model[[.x]])$bic)))
temp = bind_rows(
tibble(method = 'forward', var = names(model_coef[[1]]),
coef = model_coef[[1]], varmatch = NA_character_),
tibble(method = 'backward', var = names(model_coef[[2]]),
coef = model_coef[[2]], varmatch = NA_character_)
)
# Try to figure out programmatically which variables are in the models
for(r in 1:nrow(temp)) {
if(temp$method[r] == 'forward') {
potential_names = names(housing.factors)[agrepl(names(model_coef[[1]][r]),
names(housing.factors),
max.distance = 0.2)]
} else {
potential_names = names(housing)[agrepl(names(model_coef[[2]][r]),
names(housing.factors),
max.distance = 0.2)]
}
if(length(potential_names) == 0) {
varmatch = NA_character_
} else if(length(potential_names) == 1) {
varmatch = potential_names
} else {
varmatch = str_flatten(
intersect(
unlist(strsplit(potential_names, '')),
unlist(strsplit(potential_names, ''))
)
)
}
temp$varmatch[r] = varmatch
}
model_coef = map(1:2,
~coef(model[[.x]], which.min(summary(model[[.x]])$bic)))
temp = bind_rows(
tibble(method = 'forward', var = names(model_coef[[1]]),
coef = model_coef[[1]], varmatch = NA_character_),
tibble(method = 'backward', var = names(model_coef[[2]]),
coef = model_coef[[2]], varmatch = NA_character_)
)
# Try to figure out programmatically which variables are in the models
for(r in 1:nrow(temp)) {
if(temp$method[r] == 'forward') {
potential_names = names(housing.factors)[agrepl(names(model_coef[[1]][r]),
names(housing.factors),
max.distance = 0.3)]
} else {
potential_names = names(housing)[agrepl(names(model_coef[[2]][r]),
names(housing.factors),
max.distance = 0.3)]
}
if(length(potential_names) == 0) {
varmatch = NA_character_
} else if(length(potential_names) == 1) {
varmatch = potential_names
} else {
varmatch = str_flatten(
intersect(
unlist(strsplit(potential_names, '')),
unlist(strsplit(potential_names, ''))
)
)
}
temp$varmatch[r] = varmatch
}
# Refit: Forward
forward_predictors = c('MS.SubClass', 'Lot.Area', 'Lot.Config',
'Land.Slope', 'Neighborhood', 'Condition.1',
'Condition.2', 'House.Style', 'Overall.Cond',
'Year.Built', 'Year.Remod.Add', 'Roof.Style',
'Roof.Matl', 'Exterior.1st', 'Mas.Vnr.Area',
'Exter.Qual', 'Exter.Cond', 'Bsmt.Exposure',
'BsmtFin.Type.1', 'BsmtFin.SF.1', 'BsmtFin.SF.2',
'Heating.QC', 'Low.Qual.Fin.SF', 'Kitchen.Qual',
'TotRms.AbvGrd', 'Functional', 'Fireplace.Qu',
'Garage.Type', 'Garage.Yr.Blt', 'Garage.Cond',
'Paved.Drive', 'Wood.Deck.SF', 'Misc.Feature',
'Misc.Val', 'Yr.Sold', 'Sale.Type',
'BsmtFin.Type.1', 'Kitchen.Qual', 'Garage.Cond')
forward_pred = predict(
lm(formula(paste('SalePrice ~', str_flatten(forward_predictors, "+"))),
data = housing), #[housing$Yr.Sold != 2010, ]),
housing[housing$Yr.Sold == 2010, ]
)
forward_pred
names(housing.factors)[str_detect(names(housing.factors), "Porch")]
# Refit: Backward
backward_predictors = c('MS.SubClass', 'Lot.Area', 'Land.Slope',
'Neighborhood', 'Condition.1', 'Condition.2',
'Bldg.Type', 'Overall.Cond', 'Year.Built',
'Year.Remod.Add', 'Roof.Style', 'Roof.Matl',
'Exterior.1st', 'Mas.Vnr.Type', 'Exter.Qual',
'Exter.Cond', 'Bsmt.Cond', 'BsmtFin.Type.1',
'BsmtFin.SF.1', 'BsmtFin.SF.1', 'Heating.QC',
'Kitchen.Qual', 'Functional', 'Fireplaces',
'Fireplace.Qu', 'Garage.Type', 'Garage.Yr.Blt',
'Wood.Deck.SF', 'X3Ssn.Porch', 'Screen.Porch',
'Misc.Feature', 'Sale.Type', 'BsmtFin.Type.1',
'Garage.Cond')
# Refit: Backward
backward_predictors = c('MS.SubClass', 'Lot.Area', 'Land.Slope',
'Neighborhood', 'Condition.1', 'Condition.2',
'Bldg.Type', 'Overall.Cond', 'Year.Built',
'Year.Remod.Add', 'Roof.Style', 'Roof.Matl',
'Exterior.1st', 'Mas.Vnr.Type', 'Exter.Qual',
'Exter.Cond', 'Bsmt.Cond', 'BsmtFin.Type.1',
'BsmtFin.SF.1', 'BsmtFin.SF.1', 'Heating.QC',
'Kitchen.Qual', 'Functional', 'Fireplaces',
'Fireplace.Qu', 'Garage.Type', 'Garage.Yr.Blt',
'Wood.Deck.SF', 'X3Ssn.Porch', 'Screen.Porch',
'Misc.Feature', 'Sale.Type', 'BsmtFin.Type.1',
'Garage.Cond')
backward_pred = predict(
lm(formula(paste('SalePrice ~', str_flatten(backward_predictors, "+"))),
data = housing.factors), #[housing$Yr.Sold != 2010, ]),
housing.factors[housing.factors$Yr.Sold == 2010, ]
)
backward_pred
glm = glm(SalePrice ~ ., data = housing.factors[housing.factors$Yr.Sold != 2010, ])
names(coef(glm)[coef(summary(glm))[, "Pr(>|t|)"]  < 0.05])[-1]
glm_pred = predict(glm, housing.factors[housing.factors$Yr.Sold == 2010, ])
ls(pattern = 'pred')
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(ggplot2)
library(ggcorrplot)
library(knitr)   # contains kable() function
library(partykit)
library(caret)
library(rpart)
library(randomForest)
library(pROC)
library(leaps)
library(glmnet)
library(gbm)
set.seed(95791)
#bring in housing data
housing <- read.csv(file = "AmesHousing.csv", header = TRUE)
# #BSMT Numeric--This may need to be addressed differently. You can have a basement without a bathroom, and zero values already exist.
# Bsmt.Full.Bath
# Bsmt.Half.Bath
#Garage.Yr.Blt data is a Year value may need to be adjusted.
#Mas.Vnr.Area
if (sum(is.na(housing)) >0) {
DNE.Cols = c(74,75,76,32,33,34,35,37,8,59,65,66,62,60,29,30)
zero.Cols = c(3, 5, 49,50,61,63,64,28)
zero.Cols.alt = c(36,38,39,40) #These are all from one record (1342). Maybe just omit the record?
catchall.cols = seq(1, 82, by=1)
for (i in DNE.Cols){
housing[[i]][is.na(housing[[i]]) | housing[[i]] == ""] = "DNE" # These are stored as "", not NA, so it's not picking them up
}
for (i in zero.Cols){
housing[[i]][is.na(housing[[i]])] = 0
}
for (i in zero.Cols.alt){
housing[[i]][is.na(housing[[i]])] = 0
}
# for (i in catchall.cols){
#   housing[[i]][housing[[i]]==""] <- NA
# }
#
# for (i in catchall.cols){
#   housing[[i]][is.na(housing[[i]])] = 0
# }
#Verify NAs are removed
sum(is.na(housing))
}
sum(is.na(housing))
#Show columns that have at least one NA
housing[, colSums(is.na(housing)) > 0]
#Show rows that have at least one NA
housing[rowSums(is.na(housing)) > 0,]
# Same for housing.factors
housing.factors[, colSums(is.na(housing.factors)) > 0]
housing.factors[rowSums(is.na(housing)) > 0, ]
housing.factors <- housing
housing.factors$Exter.Cond <- factor(housing.factors$Exter.Cond, levels = c('DNE', 'Po', 'Fa', 'TA', 'Gd', 'Ex'))
housing.factors$Exter.Qual <- factor(housing.factors$Exter.Qual, levels = c('DNE', 'Po', 'Fa', 'TA', 'Gd', 'Ex'))
housing.factors$Bsmt.Qual <- factor(housing.factors$Bsmt.Qual, levels = c('DNE', 'Po', 'Fa', 'TA', 'Gd', 'Ex'))
housing.factors$Bsmt.Cond <- factor(housing.factors$Bsmt.Cond, levels = c('DNE', 'Po', 'Fa', 'TA', 'Gd', 'Ex'))
housing.factors$Kitchen.Qual <- factor(housing.factors$Kitchen.Qual, levels = c('DNE', 'Po', 'Fa', 'TA', 'Gd', 'Ex'))
housing.factors$Fireplace.Qu <- factor(housing.factors$Fireplace.Qu, levels = c('DNE', 'Po', 'Fa', 'TA', 'Gd', 'Ex'))
housing.factors$Garage.Cond <- factor(housing.factors$Garage.Cond, levels = c('DNE', 'Po', 'Fa', 'TA', 'Gd', 'Ex'))
housing.factors$Garage.Qual <- factor(housing.factors$Garage.Qual, levels = c('DNE', 'Po', 'Fa', 'TA', 'Gd', 'Ex'))
housing.factors$Pool.QC <- factor(housing.factors$Pool.QC, levels = c('DNE', 'Po', 'Fa', 'TA', 'Gd', 'Ex'))
housing.factors$Heating.QC <- factor(housing.factors$Heating.QC, levels = c('DNE', 'Po', 'Fa', 'TA', 'Gd', 'Ex'))
housing.factors$MS.SubClass <- factor(housing.factors$MS.SubClass , levels = c(20, 30, 40, 45, 50, 60, 70, 75, 80, 85, 90, 120, 150, 160, 180, 190))
# Print any columns with missing values
for(v in names(housing.factors)) {
n_na = sum(is.na(housing.factors[v]))
if(n_na > 0) {print(v); print(n_na)}
}
col.vector = seq(2, 81, by=1) #We do not need the iOrder or PID value
numeric.df <-housing[unlist(lapply(housing, is.numeric)) ]
numeric.cols <- numeric.df[,-1:-2]
numeric.cols.vec <- seq(1, ncol(numeric.cols)-1)
for (i in numeric.cols.vec){
plots<- qplot(data = housing, x = numeric.cols[,i], y = SalePrice,
xlab = paste(colnames(numeric.cols)[i]) , ylab = "SalePrice") + stat_smooth(method = "lm")
print(plots)
}
cor.housing.sales <- cor(numeric.df[,-1:-2])
ggcorrplot(cor.housing.sales)
qual.cols.vec <-  c(29, 30, 32, 33, 42, 55, 59, 65, 66, 74)
for (i in qual.cols.vec){
boxplots <- qplot(data = housing.factors, x = housing.factors[,i], y = SalePrice, geom = "boxplot", xlab = paste(colnames(housing.factors)[i]))
print(boxplots)
}
qual.cols.vec <-  c(3, 4, 7, 8 , 9 , 10, 11, 12, 13, 14, 15, 16, 17,
18, 23, 24, 25, 26, 27, 31, 35, 37, 41, 44, 57,
60, 62, 67, 75, 76, 80, 81)
for (i in qual.cols.vec){
boxplots <- qplot(data = housing.factors, x = housing.factors[,i], y = SalePrice, geom = "boxplot", xlab = paste(colnames(housing.factors)[i]))
print(boxplots)
}
#Note all variables that are used in models, so we can retain their box plots:
# Forward and backward stepwise (best subset will be too time-intensive)
nvmax = 1000 #ncol(housing)
model = map(
.x = c('forward', 'backward'),
.f = ~regsubsets(SalePrice ~ .,
data = housing.factors[housing.factors$Yr.Sold != 2010, ],
nvmax = nvmax, method = .x, really.big = F)
)
# Find optimal models
for(.x in 1:2) {
num_variables = 1:length(summary(model[[.x]])$rss)
# R^2
plot_RSQ = ggplot(data = data.frame(summary(model[[.x]])$rsq),
aes(x = num_variables, y = summary(model[[.x]])$rsq)) +
geom_line() +
geom_point(x = which.max(summary(model[[.x]])$rsq),
y = max(summary(model[[.x]])$rsq), aes(color = "red"),
show.legend = FALSE) +
xlab("# Variables") +
ylab("R-squared") +
theme_bw()
# RSS
plot_RSS = ggplot(data = data.frame(summary(model[[.x]])$rss),
aes(x = num_variables, y = summary(model[[.x]])$rss)) +
geom_line() +
geom_point(x = which.min(summary(model[[.x]])$rss),
y = min(summary(model[[.x]])$rss), aes(color = "red"),
show.legend = FALSE) +
xlab("# Variables") +
ylab("RSS") +
theme_bw()
# BIC
plot_BIC = ggplot(data = data.frame(summary(model[[.x]])$bic),
aes(x = num_variables, y = summary(model[[.x]])$bic)) +
geom_line() +
geom_point(x = which.min(summary(model[[.x]])$bic),
y = min(summary(model[[.x]])$bic), aes(color = "red"),
show.legend = FALSE) +
xlab("# Variables") +
ylab("BIC") +
ggtitle("BIC",
str_c("Optimal value at ", which.min(summary(model[[.x]])$bic))) +
theme_bw()
# AIC
plot_AIC = ggplot(data = data.frame(summary(model[[.x]])$cp),
aes(x = num_variables, y = summary(model[[.x]])$cp)) +
geom_line() +
geom_point(x = which.min(summary(model[[.x]])$cp),
y = min(summary(model[[.x]])$cp), aes(color = "red"),
show.legend = FALSE) +
xlab("# Variables") +
ylab("AIC") +
ggtitle("AIC",
str_c("Optimal value at ", which.min(summary(model[[.x]])$cp))) +
theme_bw()
# Plot
gridExtra::grid.arrange(plot_RSQ, plot_RSS, plot_AIC, plot_BIC,
ncol = 2, nrow = 2)
}
# Get predictions from optimal models
model_coef = map(1:2,
~coef(model[[.x]], which.min(summary(model[[.x]])$bic)))
temp = bind_rows(
tibble(method = 'forward', var = names(model_coef[[1]]),
coef = model_coef[[1]], varmatch = NA_character_),
tibble(method = 'backward', var = names(model_coef[[2]]),
coef = model_coef[[2]], varmatch = NA_character_)
)
# Try to figure out programmatically which variables are in the models
for(r in 1:nrow(temp)) {
if(temp$method[r] == 'forward') {
potential_names = names(housing.factors)[agrepl(names(model_coef[[1]][r]),
names(housing.factors),
max.distance = 0.3)]
} else {
potential_names = names(housing.factors)[agrepl(names(model_coef[[2]][r]),
names(housing.factors),
max.distance = 0.3)]
}
if(length(potential_names) == 0) {
varmatch = NA_character_
} else if(length(potential_names) == 1) {
varmatch = potential_names
} else {
varmatch = str_flatten(
intersect(
unlist(strsplit(potential_names, '')),
unlist(strsplit(potential_names, ''))
)
)
}
temp$varmatch[r] = varmatch
}
# Refit: Forward
forward_predictors = c('MS.SubClass', 'Lot.Area', 'Lot.Config',
'Land.Slope', 'Neighborhood', 'Condition.1',
'Condition.2', 'House.Style', 'Overall.Cond',
'Year.Built', 'Year.Remod.Add', 'Roof.Style',
'Roof.Matl', 'Exterior.1st', 'Mas.Vnr.Area',
'Exter.Qual', 'Exter.Cond', 'Bsmt.Exposure',
'BsmtFin.Type.1', 'BsmtFin.SF.1', 'BsmtFin.SF.2',
'Heating.QC', 'Low.Qual.Fin.SF', 'Kitchen.Qual',
'TotRms.AbvGrd', 'Functional', 'Fireplace.Qu',
'Garage.Type', 'Garage.Yr.Blt', 'Garage.Cond',
'Paved.Drive', 'Wood.Deck.SF', 'Misc.Feature',
'Misc.Val', 'Yr.Sold', 'Sale.Type',
'BsmtFin.Type.1', 'Kitchen.Qual', 'Garage.Cond')
forward_pred = predict(
lm(formula(paste('SalePrice ~', str_flatten(forward_predictors, "+"))),
data = housing.factors), #[housing$Yr.Sold != 2010, ]),
housing.factors[housing.factors$Yr.Sold == 2010, ]
)
# Refit: Backward
backward_predictors = c('MS.SubClass', 'Lot.Area', 'Land.Slope',
'Neighborhood', 'Condition.1', 'Condition.2',
'Bldg.Type', 'Overall.Cond', 'Year.Built',
'Year.Remod.Add', 'Roof.Style', 'Roof.Matl',
'Exterior.1st', 'Mas.Vnr.Type', 'Exter.Qual',
'Exter.Cond', 'Bsmt.Cond', 'BsmtFin.Type.1',
'BsmtFin.SF.1', 'BsmtFin.SF.1', 'Heating.QC',
'Kitchen.Qual', 'Functional', 'Fireplaces',
'Fireplace.Qu', 'Garage.Type', 'Garage.Yr.Blt',
'Wood.Deck.SF', 'X3Ssn.Porch', 'Screen.Porch',
'Misc.Feature', 'Sale.Type', 'BsmtFin.Type.1',
'Garage.Cond')
backward_pred = predict(
lm(formula(paste('SalePrice ~', str_flatten(backward_predictors, "+"))),
data = housing.factors), #[housing$Yr.Sold != 2010, ]),
housing.factors[housing.factors$Yr.Sold == 2010, ]
)
# GLM
glm = glm(SalePrice ~ ., data = housing.factors[housing.factors$Yr.Sold != 2010, ])
names(coef(glm)[coef(summary(glm))[, "Pr(>|t|)"]  < 0.05])[-1]
# Lasso [Primary]
# Define x and y objects for Lasso, as well as specifying training data
train = which(housing.factors$Yr.Sold != 2010)
x = model.matrix(SalePrice ~ ., housing.factors)[, -1]
y = housing.factors$SalePrice
# Fit and plot model
lasso_model = cv.glmnet(x[train, ], y[train] , alpha = 1)
plot(lasso_model)
ls(pattern = 'pred')
map(list(forward_pred = forward_pred, backward_pred = backward_pred,
lasso_pred = lasso_pred, boost_pred = boost_pred),
~performance_metrics(predicted = .x))
for(.x in 1:5) {
plot(boost_model, i = summary(boost_model)[.x, 'var'])
}
boost_pred = predict(boost_model,
newdata = housing.factors[housing.factors$Yr.Sold == 2010, ],
n.trees = 5000)
train = which(housing.factors$Yr.Sold != 2010)
x = model.matrix(SalePrice ~ ., housing.factors)[, -1]
y = housing.factors$SalePrice
# Fit and plot model
lasso_model = cv.glmnet(x[train, ], y[train] , alpha = 1)
plot(lasso_model)
lasso_model$lambda.min; lasso_model$lambda.1se
lasso_pred = predict(lasso_model, s = lasso_model$lambda.1se,
newx = x[-train, ])
boost_model = gbm(SalePrice ~ .,
data = mutate_if(housing.factors, is.character, as.factor)[housing.factors$Yr.Sold != 2010, ],
distribution = 'gaussian',
n.trees = 5000,
cv.folds = 10,
shrinkage = 0.1,
interaction.depth = 4)
boost_pred = predict(boost_model,
newdata = housing.factors[housing.factors$Yr.Sold == 2010, ],
n.trees = 5000)
map(list(forward_pred = forward_pred, backward_pred = backward_pred,
lasso_pred = lasso_pred, boost_pred = boost_pred),
~performance_metrics(predicted = .x))
performance_metrics = function(actual = housing.factors[housing.factors$Yr.Sold == 2010, 'SalePrice'], predicted, plot = T, by_neighborhood = F) {
# Check that actual and predicted values are the same length
if(length(actual) != length(predicted)) {
message("'actual' and 'predicted' vectors must be the same length.")
} else {
# Compute metrics (MSE, RMSE, MAE, relative error)
# Including by neighborhood
if(by_neighborhood) {
metrics = tibble(
neighborhood = housing.factors[housing.factors$Yr.Sold == 2010, 'Neighborhood'],
actual = actual,
predicted = as.numeric(predicted),
mse = (actual - predicted)^2,
mae = abs(actual - predicted),
rel_error = (predicted - actual) / actual
) %>%
group_by(neighborhood) %>%
summarize(across(mse:rel_error, mean)) %>%
ungroup()
# Plot
barplot = ggplot(data = pivot_longer(metrics, cols = mse:rel_error,
names_to = 'performance_metric',
values_to = 'metric_score'),
aes(x = performance_metric, y = metric_score)) +
geom_bar(stat = 'identity') +
geom_text(aes(label = round(metric_score, 3))) +
xlab("Metric") +
ylab("Score") +
facet_wrap(~neighborhood) +
theme_bw()
scatter = ggplot(data = tibble(
neighborhood = housing.factors[housing.factors$Yr.Sold == 2010, 'Neighborhood'],
actual = actual,
predicted = predicted),
aes(x = actual, y = predicted)) +
geom_point(aes(size = abs(actual - predicted)), alpha = 0.4) +
xlab("Actual") +
ylab("Predicted") +
facet_wrap('neighborhood') +
geom_abline(slope = 1, intercept = 0, col = 'red') +
theme_bw()
} else {
# Compute error and create data frame
mse = mean((actual - predicted)^2)
mae = mean(abs(actual - predicted))
rel_error = mean((predicted - actual) / actual)
metrics = tibble(mse = mse, mae = mae, rel_error = rel_error)
# Plot
barplot = ggplot(data = tibble(mse, mae, rel_error) %>%
pivot_longer(cols = everything(),
names_to = 'performance_metric',
values_to = 'metric_score'),
aes(x = performance_metric, y = metric_score)) +
geom_bar(stat = 'identity') +
geom_text(aes(label = round(metric_score, 3))) +
xlab("Metric") +
ylab("Score") +
theme_bw()
scatter = ggplot(data = tibble(actual = actual,
predicted = predicted),
aes(x = actual, y = predicted)) +
geom_point(aes(size = abs(actual - predicted)), alpha = 0.4) +
xlab("Actual") +
ylab("Predicted") +
geom_abline(slope = 1, intercept = 0, col = 'red') +
theme_bw()
}
# Return objects
if(plot) {
return(list(metrics = metrics, barplot = barplot, scatter = scatter))
} else {
return(list(metrics = metrics))
}
}
}
map(list(forward_pred = forward_pred, backward_pred = backward_pred,
lasso_pred = lasso_pred, boost_pred = boost_pred),
~performance_metrics(predicted = .x))
map(list(forward_pred = forward_pred, backward_pred = backward_pred,
lasso_pred = lasso_pred, boost_pred = boost_pred),
~performance_metrics(predicted = .x, by_neighborhood = T))
